package sqlmodel

import (
	"bytes"
	"fmt"
	"io"
	"sort"
	"strings"
	"time"

	"github.com/go-openapi/inflect"
	"golang.org/x/tools/imports"
)

var _ Generator = &ModelGenerator{}
var _ Generator = &QueryGenerator{}

// ModelGenerator generates Golang structs from database schema
type ModelGenerator struct {
	// TagBuilder builds struct tags from column type
	TagBuilder TagBuilder
	// Config controls how the code generation happens
	Config *ModelGeneratorConfig
}

// Generate generates the golang structs from database schema
func (g *ModelGenerator) Generate(ctx *GeneratorContext) error {
	pkg := ctx.Package
	schema := ctx.Schema
	buffer := &bytes.Buffer{}
	tables := tables(g.Config.IgnoreTables, schema)

	if len(tables) == 0 {
		return nil
	}

	g.writePackage(pkg, schema.Name, buffer)

	for _, table := range tables {
		g.writeTable(pkg, schema.IsDefault, &table, buffer)
	}

	if err := g.format(buffer); err != nil {
		return err
	}

	_, err := io.Copy(ctx.Writer, buffer)
	return err
}

func (g *ModelGenerator) writePackage(pkg, name string, buffer io.Writer) {
	if g.Config.InlcudeDoc {
		fmt.Fprintln(buffer, "// Code generated by prana; DO NOT EDIT.")
		fmt.Fprintln(buffer)
		fmt.Fprintf(buffer, "// Package %s contains an object model of database schema '%s'\n", pkg, name)
		fmt.Fprintln(buffer, "// Auto-generated at", time.Now().Format(time.RFC1123))
	}

	fmt.Fprintf(buffer, "package ")
	fmt.Fprintf(buffer, pkg)
	fmt.Fprintln(buffer)
}

func (g *ModelGenerator) writeTable(pkg string, isDefaultSchema bool, table *Table, buffer io.Writer) {
	columns := table.Columns
	length := len(columns)
	typeName := g.typeName(pkg, isDefaultSchema, table)

	if g.Config.InlcudeDoc {
		fmt.Fprintln(buffer)
		fmt.Fprintf(buffer, "// %s represents a data base table '%s'", typeName, table.Name)
		fmt.Fprintln(buffer)
	}

	fmt.Fprintf(buffer, "type %v struct {", typeName)
	fmt.Fprintln(buffer)

	for index, column := range columns {
		current := column
		fieldName := g.fieldName(&current)
		fieldType := g.fieldType(&current)
		fieldTag := g.TagBuilder.Build(&current)

		if g.Config.InlcudeDoc {
			if index > 0 {
				fmt.Fprintln(buffer)
			}
			fmt.Fprintf(buffer, "// %s represents a database column '%s' of type '%v'", fieldName, column.Name, column.Type)
			fmt.Fprintln(buffer)
		}

		fmt.Fprint(buffer, fieldName)
		fmt.Fprint(buffer, " ")
		fmt.Fprint(buffer, fieldType)
		fmt.Fprint(buffer, " ")
		fmt.Fprint(buffer, fieldTag)

		fmt.Fprintln(buffer)

		if index == length-1 {
			fmt.Fprintln(buffer, "}")
		}
	}
}

func (g *ModelGenerator) typeName(pkg string, isDefaultSchema bool, table *Table) string {
	name := inflect.Camelize(table.Name)
	name = inflect.Singularize(name)
	return name
}

func (g *ModelGenerator) fieldName(column *Column) string {
	name := inflect.Camelize(column.Name)
	name = strings.Replace(name, "Id", "ID", -1)
	return name
}

func (g *ModelGenerator) fieldType(column *Column) string {
	return column.ScanType
}

func (g *ModelGenerator) format(buffer *bytes.Buffer) error {
	data, err := imports.Process("model", buffer.Bytes(), nil)
	if err != nil {
		return err
	}

	buffer.Reset()

	_, err = buffer.Write(data)
	return err
}

// QueryGenerator generates queries for give schema
type QueryGenerator struct {
	// Config controls how the code generation happens
	Config *QueryGeneratorConfig
}

// Generate generates a script for given schema
func (g *QueryGenerator) Generate(ctx *GeneratorContext) error {
	schema := ctx.Schema
	buffer := &bytes.Buffer{}
	tables := tables(g.Config.IgnoreTables, schema)

	if len(tables) == 0 {
		return nil
	}

	g.writeSQLComment(buffer)

	for index, table := range tables {
		if index > 0 {
			fmt.Fprintln(buffer)
		}

		g.writeSQLQuerySelectAll(buffer, schema, &table)
		g.writeSQLQuerySelect(buffer, schema, &table)
		g.writeSQLQueryInsert(buffer, schema, &table)
		g.writeSQLQueryUpdate(buffer, schema, &table)
		g.writeSQLQueryDelete(buffer, schema, &table)
	}

	_, err := io.Copy(ctx.Writer, buffer)
	return err
}

func (g *QueryGenerator) writeSQLQuerySelectAll(w io.Writer, schema *Schema, table *Table) {
	tableName := g.tableName(schema, table)
	fmt.Fprintf(w, "-- name: select-all-%s\n", g.commandName(tableName, false))
	fmt.Fprintf(w, "SELECT * FROM %s;\n\n", tableName)
}

func (g *QueryGenerator) writeSQLQuerySelect(w io.Writer, schema *Schema, table *Table) {
	tableName := g.tableName(schema, table)
	condition := g.pkCondition(table)

	if len(condition) == 0 {
		return
	}

	fmt.Fprintf(w, "-- name: select-%s\n", g.commandName(tableName, true))
	fmt.Fprintf(w, "SELECT * FROM %s\n", tableName)
	fmt.Fprintf(w, "WHERE %s;\n\n", condition)
}

func (g *QueryGenerator) writeSQLQueryInsert(w io.Writer, schema *Schema, table *Table) {
	tableName := g.tableName(schema, table)
	columns, values := g.insertParam(table)

	if len(columns) == 0 || len(values) == 0 {
		return
	}

	fmt.Fprintf(w, "-- name: insert-%s\n", g.commandName(tableName, true))
	fmt.Fprintf(w, "INSERT INTO %s (%s)\n", tableName, columns)
	fmt.Fprintf(w, "VALUES (%s);\n\n", values)
}

func (g *QueryGenerator) writeSQLQueryUpdate(w io.Writer, schema *Schema, table *Table) {
	tableName := g.tableName(schema, table)
	condition, values := g.updateParam(table)

	if len(condition) == 0 || len(values) == 0 {
		return
	}

	fmt.Fprintf(w, "-- name: update-%s\n", g.commandName(tableName, true))
	fmt.Fprintf(w, "UPDATE %s\n", tableName)
	fmt.Fprintf(w, "SET %s\n", values)
	fmt.Fprintf(w, "WHERE %s;\n\n", condition)
}

func (g *QueryGenerator) writeSQLQueryDelete(w io.Writer, schema *Schema, table *Table) {
	tableName := g.tableName(schema, table)
	condition := g.pkCondition(table)

	if len(condition) == 0 {
		return
	}

	fmt.Fprintf(w, "-- name: delete-%s\n", g.commandName(tableName, true))
	fmt.Fprintf(w, "DELETE FROM %s\n", tableName)
	fmt.Fprintf(w, "WHERE %s;\n", condition)
}

func (g *QueryGenerator) writeSQLComment(w io.Writer) {
	if g.Config.InlcudeDoc {
		fmt.Fprintln(w, "-- Auto-generated at", time.Now().Format(time.UnixDate))
		fmt.Fprintln(w)
	}
}

func (g *QueryGenerator) commandName(name string, singularize bool) string {
	name = strings.Replace(name, ".", "-", -1)
	name = strings.Replace(name, "_", "-", -1)
	if singularize {
		name = inflect.Singularize(name)
	}
	return name
}

func (g *QueryGenerator) tableName(schema *Schema, table *Table) string {
	name := table.Name

	if !schema.IsDefault {
		name = fmt.Sprintf("%s.%s", schema.Name, name)
	}

	return name
}

func (g *QueryGenerator) insertParam(table *Table) (string, string) {
	var (
		columns []string
		values  []string
		param   string
	)

	for _, column := range table.Columns {
		columns = append(columns, column.Name)

		if g.Config.UseNamedParams {
			param = fmt.Sprintf(":%s", column.Name)
		} else {
			param = "?"
		}

		values = append(values, param)
	}

	return strings.Join(columns, ", "), strings.Join(values, ", ")
}

func (g *QueryGenerator) updateParam(table *Table) (string, string) {
	var (
		values     []string
		conditions []string
		param      string
	)

	for _, column := range table.Columns {
		if g.Config.UseNamedParams {
			param = fmt.Sprintf("%s = :%s", column.Name, column.Name)
		} else {
			param = fmt.Sprintf("%s = ?", column.Name)
		}

		if column.Type.IsPrimaryKey {
			conditions = append(conditions, param)
		} else {
			values = append(values, param)
		}
	}

	return strings.Join(conditions, ", "), strings.Join(values, ", ")
}

func (g *QueryGenerator) pkCondition(table *Table) string {
	var (
		conditions []string
		param      string
	)

	for _, column := range table.Columns {
		if !column.Type.IsPrimaryKey {
			continue
		}

		if g.Config.UseNamedParams {
			param = fmt.Sprintf("%s = :%s", column.Name, column.Name)
		} else {
			param = fmt.Sprintf("%s = ?", column.Name)
		}

		conditions = append(conditions, param)
	}

	return strings.Join(conditions, " AND ")
}

func tables(ignore []string, schema *Schema) []Table {
	tables := []Table{}

	if !sort.StringsAreSorted(ignore) {
		sort.Strings(ignore)
	}

	for _, table := range schema.Tables {
		if index := sort.SearchStrings(ignore, table.Name); index < len(ignore) {
			if ignore[index] == table.Name {
				continue
			}
		}

		tables = append(tables, table)
	}
	return tables
}
