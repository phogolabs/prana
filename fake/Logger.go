// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"sync"

	"github.com/phogolabs/log"
	"github.com/phogolabs/prana"
)

type Logger struct {
	AlertStub        func(...interface{})
	alertMutex       sync.RWMutex
	alertArgsForCall []struct {
		arg1 []interface{}
	}
	AlertfStub        func(string, ...interface{})
	alertfMutex       sync.RWMutex
	alertfArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	DebugStub        func(...interface{})
	debugMutex       sync.RWMutex
	debugArgsForCall []struct {
		arg1 []interface{}
	}
	DebugfStub        func(string, ...interface{})
	debugfMutex       sync.RWMutex
	debugfArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	ErrorStub        func(...interface{})
	errorMutex       sync.RWMutex
	errorArgsForCall []struct {
		arg1 []interface{}
	}
	ErrorfStub        func(string, ...interface{})
	errorfMutex       sync.RWMutex
	errorfArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	FatalStub        func(...interface{})
	fatalMutex       sync.RWMutex
	fatalArgsForCall []struct {
		arg1 []interface{}
	}
	FatalfStub        func(string, ...interface{})
	fatalfMutex       sync.RWMutex
	fatalfArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	FieldsStub        func() log.Map
	fieldsMutex       sync.RWMutex
	fieldsArgsForCall []struct {
	}
	fieldsReturns struct {
		result1 log.Map
	}
	fieldsReturnsOnCall map[int]struct {
		result1 log.Map
	}
	InfoStub        func(...interface{})
	infoMutex       sync.RWMutex
	infoArgsForCall []struct {
		arg1 []interface{}
	}
	InfofStub        func(string, ...interface{})
	infofMutex       sync.RWMutex
	infofArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	NoticeStub        func(...interface{})
	noticeMutex       sync.RWMutex
	noticeArgsForCall []struct {
		arg1 []interface{}
	}
	NoticefStub        func(string, ...interface{})
	noticefMutex       sync.RWMutex
	noticefArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	PanicStub        func(...interface{})
	panicMutex       sync.RWMutex
	panicArgsForCall []struct {
		arg1 []interface{}
	}
	PanicfStub        func(string, ...interface{})
	panicfMutex       sync.RWMutex
	panicfArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	WarnStub        func(...interface{})
	warnMutex       sync.RWMutex
	warnArgsForCall []struct {
		arg1 []interface{}
	}
	WarnfStub        func(string, ...interface{})
	warnfMutex       sync.RWMutex
	warnfArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	WithErrorStub        func(error) log.Logger
	withErrorMutex       sync.RWMutex
	withErrorArgsForCall []struct {
		arg1 error
	}
	withErrorReturns struct {
		result1 log.Logger
	}
	withErrorReturnsOnCall map[int]struct {
		result1 log.Logger
	}
	WithFieldStub        func(string, interface{}) log.Logger
	withFieldMutex       sync.RWMutex
	withFieldArgsForCall []struct {
		arg1 string
		arg2 interface{}
	}
	withFieldReturns struct {
		result1 log.Logger
	}
	withFieldReturnsOnCall map[int]struct {
		result1 log.Logger
	}
	WithFieldsStub        func(log.Map) log.Logger
	withFieldsMutex       sync.RWMutex
	withFieldsArgsForCall []struct {
		arg1 log.Map
	}
	withFieldsReturns struct {
		result1 log.Logger
	}
	withFieldsReturnsOnCall map[int]struct {
		result1 log.Logger
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Logger) Alert(arg1 ...interface{}) {
	fake.alertMutex.Lock()
	fake.alertArgsForCall = append(fake.alertArgsForCall, struct {
		arg1 []interface{}
	}{arg1})
	fake.recordInvocation("Alert", []interface{}{arg1})
	fake.alertMutex.Unlock()
	if fake.AlertStub != nil {
		fake.AlertStub(arg1...)
	}
}

func (fake *Logger) AlertCallCount() int {
	fake.alertMutex.RLock()
	defer fake.alertMutex.RUnlock()
	return len(fake.alertArgsForCall)
}

func (fake *Logger) AlertCalls(stub func(...interface{})) {
	fake.alertMutex.Lock()
	defer fake.alertMutex.Unlock()
	fake.AlertStub = stub
}

func (fake *Logger) AlertArgsForCall(i int) []interface{} {
	fake.alertMutex.RLock()
	defer fake.alertMutex.RUnlock()
	argsForCall := fake.alertArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Logger) Alertf(arg1 string, arg2 ...interface{}) {
	fake.alertfMutex.Lock()
	fake.alertfArgsForCall = append(fake.alertfArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	fake.recordInvocation("Alertf", []interface{}{arg1, arg2})
	fake.alertfMutex.Unlock()
	if fake.AlertfStub != nil {
		fake.AlertfStub(arg1, arg2...)
	}
}

func (fake *Logger) AlertfCallCount() int {
	fake.alertfMutex.RLock()
	defer fake.alertfMutex.RUnlock()
	return len(fake.alertfArgsForCall)
}

func (fake *Logger) AlertfCalls(stub func(string, ...interface{})) {
	fake.alertfMutex.Lock()
	defer fake.alertfMutex.Unlock()
	fake.AlertfStub = stub
}

func (fake *Logger) AlertfArgsForCall(i int) (string, []interface{}) {
	fake.alertfMutex.RLock()
	defer fake.alertfMutex.RUnlock()
	argsForCall := fake.alertfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Logger) Debug(arg1 ...interface{}) {
	fake.debugMutex.Lock()
	fake.debugArgsForCall = append(fake.debugArgsForCall, struct {
		arg1 []interface{}
	}{arg1})
	fake.recordInvocation("Debug", []interface{}{arg1})
	fake.debugMutex.Unlock()
	if fake.DebugStub != nil {
		fake.DebugStub(arg1...)
	}
}

func (fake *Logger) DebugCallCount() int {
	fake.debugMutex.RLock()
	defer fake.debugMutex.RUnlock()
	return len(fake.debugArgsForCall)
}

func (fake *Logger) DebugCalls(stub func(...interface{})) {
	fake.debugMutex.Lock()
	defer fake.debugMutex.Unlock()
	fake.DebugStub = stub
}

func (fake *Logger) DebugArgsForCall(i int) []interface{} {
	fake.debugMutex.RLock()
	defer fake.debugMutex.RUnlock()
	argsForCall := fake.debugArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Logger) Debugf(arg1 string, arg2 ...interface{}) {
	fake.debugfMutex.Lock()
	fake.debugfArgsForCall = append(fake.debugfArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	fake.recordInvocation("Debugf", []interface{}{arg1, arg2})
	fake.debugfMutex.Unlock()
	if fake.DebugfStub != nil {
		fake.DebugfStub(arg1, arg2...)
	}
}

func (fake *Logger) DebugfCallCount() int {
	fake.debugfMutex.RLock()
	defer fake.debugfMutex.RUnlock()
	return len(fake.debugfArgsForCall)
}

func (fake *Logger) DebugfCalls(stub func(string, ...interface{})) {
	fake.debugfMutex.Lock()
	defer fake.debugfMutex.Unlock()
	fake.DebugfStub = stub
}

func (fake *Logger) DebugfArgsForCall(i int) (string, []interface{}) {
	fake.debugfMutex.RLock()
	defer fake.debugfMutex.RUnlock()
	argsForCall := fake.debugfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Logger) Error(arg1 ...interface{}) {
	fake.errorMutex.Lock()
	fake.errorArgsForCall = append(fake.errorArgsForCall, struct {
		arg1 []interface{}
	}{arg1})
	fake.recordInvocation("Error", []interface{}{arg1})
	fake.errorMutex.Unlock()
	if fake.ErrorStub != nil {
		fake.ErrorStub(arg1...)
	}
}

func (fake *Logger) ErrorCallCount() int {
	fake.errorMutex.RLock()
	defer fake.errorMutex.RUnlock()
	return len(fake.errorArgsForCall)
}

func (fake *Logger) ErrorCalls(stub func(...interface{})) {
	fake.errorMutex.Lock()
	defer fake.errorMutex.Unlock()
	fake.ErrorStub = stub
}

func (fake *Logger) ErrorArgsForCall(i int) []interface{} {
	fake.errorMutex.RLock()
	defer fake.errorMutex.RUnlock()
	argsForCall := fake.errorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Logger) Errorf(arg1 string, arg2 ...interface{}) {
	fake.errorfMutex.Lock()
	fake.errorfArgsForCall = append(fake.errorfArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	fake.recordInvocation("Errorf", []interface{}{arg1, arg2})
	fake.errorfMutex.Unlock()
	if fake.ErrorfStub != nil {
		fake.ErrorfStub(arg1, arg2...)
	}
}

func (fake *Logger) ErrorfCallCount() int {
	fake.errorfMutex.RLock()
	defer fake.errorfMutex.RUnlock()
	return len(fake.errorfArgsForCall)
}

func (fake *Logger) ErrorfCalls(stub func(string, ...interface{})) {
	fake.errorfMutex.Lock()
	defer fake.errorfMutex.Unlock()
	fake.ErrorfStub = stub
}

func (fake *Logger) ErrorfArgsForCall(i int) (string, []interface{}) {
	fake.errorfMutex.RLock()
	defer fake.errorfMutex.RUnlock()
	argsForCall := fake.errorfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Logger) Fatal(arg1 ...interface{}) {
	fake.fatalMutex.Lock()
	fake.fatalArgsForCall = append(fake.fatalArgsForCall, struct {
		arg1 []interface{}
	}{arg1})
	fake.recordInvocation("Fatal", []interface{}{arg1})
	fake.fatalMutex.Unlock()
	if fake.FatalStub != nil {
		fake.FatalStub(arg1...)
	}
}

func (fake *Logger) FatalCallCount() int {
	fake.fatalMutex.RLock()
	defer fake.fatalMutex.RUnlock()
	return len(fake.fatalArgsForCall)
}

func (fake *Logger) FatalCalls(stub func(...interface{})) {
	fake.fatalMutex.Lock()
	defer fake.fatalMutex.Unlock()
	fake.FatalStub = stub
}

func (fake *Logger) FatalArgsForCall(i int) []interface{} {
	fake.fatalMutex.RLock()
	defer fake.fatalMutex.RUnlock()
	argsForCall := fake.fatalArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Logger) Fatalf(arg1 string, arg2 ...interface{}) {
	fake.fatalfMutex.Lock()
	fake.fatalfArgsForCall = append(fake.fatalfArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	fake.recordInvocation("Fatalf", []interface{}{arg1, arg2})
	fake.fatalfMutex.Unlock()
	if fake.FatalfStub != nil {
		fake.FatalfStub(arg1, arg2...)
	}
}

func (fake *Logger) FatalfCallCount() int {
	fake.fatalfMutex.RLock()
	defer fake.fatalfMutex.RUnlock()
	return len(fake.fatalfArgsForCall)
}

func (fake *Logger) FatalfCalls(stub func(string, ...interface{})) {
	fake.fatalfMutex.Lock()
	defer fake.fatalfMutex.Unlock()
	fake.FatalfStub = stub
}

func (fake *Logger) FatalfArgsForCall(i int) (string, []interface{}) {
	fake.fatalfMutex.RLock()
	defer fake.fatalfMutex.RUnlock()
	argsForCall := fake.fatalfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Logger) Fields() log.Map {
	fake.fieldsMutex.Lock()
	ret, specificReturn := fake.fieldsReturnsOnCall[len(fake.fieldsArgsForCall)]
	fake.fieldsArgsForCall = append(fake.fieldsArgsForCall, struct {
	}{})
	fake.recordInvocation("Fields", []interface{}{})
	fake.fieldsMutex.Unlock()
	if fake.FieldsStub != nil {
		return fake.FieldsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.fieldsReturns
	return fakeReturns.result1
}

func (fake *Logger) FieldsCallCount() int {
	fake.fieldsMutex.RLock()
	defer fake.fieldsMutex.RUnlock()
	return len(fake.fieldsArgsForCall)
}

func (fake *Logger) FieldsCalls(stub func() log.Map) {
	fake.fieldsMutex.Lock()
	defer fake.fieldsMutex.Unlock()
	fake.FieldsStub = stub
}

func (fake *Logger) FieldsReturns(result1 log.Map) {
	fake.fieldsMutex.Lock()
	defer fake.fieldsMutex.Unlock()
	fake.FieldsStub = nil
	fake.fieldsReturns = struct {
		result1 log.Map
	}{result1}
}

func (fake *Logger) FieldsReturnsOnCall(i int, result1 log.Map) {
	fake.fieldsMutex.Lock()
	defer fake.fieldsMutex.Unlock()
	fake.FieldsStub = nil
	if fake.fieldsReturnsOnCall == nil {
		fake.fieldsReturnsOnCall = make(map[int]struct {
			result1 log.Map
		})
	}
	fake.fieldsReturnsOnCall[i] = struct {
		result1 log.Map
	}{result1}
}

func (fake *Logger) Info(arg1 ...interface{}) {
	fake.infoMutex.Lock()
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct {
		arg1 []interface{}
	}{arg1})
	fake.recordInvocation("Info", []interface{}{arg1})
	fake.infoMutex.Unlock()
	if fake.InfoStub != nil {
		fake.InfoStub(arg1...)
	}
}

func (fake *Logger) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *Logger) InfoCalls(stub func(...interface{})) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = stub
}

func (fake *Logger) InfoArgsForCall(i int) []interface{} {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	argsForCall := fake.infoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Logger) Infof(arg1 string, arg2 ...interface{}) {
	fake.infofMutex.Lock()
	fake.infofArgsForCall = append(fake.infofArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	fake.recordInvocation("Infof", []interface{}{arg1, arg2})
	fake.infofMutex.Unlock()
	if fake.InfofStub != nil {
		fake.InfofStub(arg1, arg2...)
	}
}

func (fake *Logger) InfofCallCount() int {
	fake.infofMutex.RLock()
	defer fake.infofMutex.RUnlock()
	return len(fake.infofArgsForCall)
}

func (fake *Logger) InfofCalls(stub func(string, ...interface{})) {
	fake.infofMutex.Lock()
	defer fake.infofMutex.Unlock()
	fake.InfofStub = stub
}

func (fake *Logger) InfofArgsForCall(i int) (string, []interface{}) {
	fake.infofMutex.RLock()
	defer fake.infofMutex.RUnlock()
	argsForCall := fake.infofArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Logger) Notice(arg1 ...interface{}) {
	fake.noticeMutex.Lock()
	fake.noticeArgsForCall = append(fake.noticeArgsForCall, struct {
		arg1 []interface{}
	}{arg1})
	fake.recordInvocation("Notice", []interface{}{arg1})
	fake.noticeMutex.Unlock()
	if fake.NoticeStub != nil {
		fake.NoticeStub(arg1...)
	}
}

func (fake *Logger) NoticeCallCount() int {
	fake.noticeMutex.RLock()
	defer fake.noticeMutex.RUnlock()
	return len(fake.noticeArgsForCall)
}

func (fake *Logger) NoticeCalls(stub func(...interface{})) {
	fake.noticeMutex.Lock()
	defer fake.noticeMutex.Unlock()
	fake.NoticeStub = stub
}

func (fake *Logger) NoticeArgsForCall(i int) []interface{} {
	fake.noticeMutex.RLock()
	defer fake.noticeMutex.RUnlock()
	argsForCall := fake.noticeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Logger) Noticef(arg1 string, arg2 ...interface{}) {
	fake.noticefMutex.Lock()
	fake.noticefArgsForCall = append(fake.noticefArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	fake.recordInvocation("Noticef", []interface{}{arg1, arg2})
	fake.noticefMutex.Unlock()
	if fake.NoticefStub != nil {
		fake.NoticefStub(arg1, arg2...)
	}
}

func (fake *Logger) NoticefCallCount() int {
	fake.noticefMutex.RLock()
	defer fake.noticefMutex.RUnlock()
	return len(fake.noticefArgsForCall)
}

func (fake *Logger) NoticefCalls(stub func(string, ...interface{})) {
	fake.noticefMutex.Lock()
	defer fake.noticefMutex.Unlock()
	fake.NoticefStub = stub
}

func (fake *Logger) NoticefArgsForCall(i int) (string, []interface{}) {
	fake.noticefMutex.RLock()
	defer fake.noticefMutex.RUnlock()
	argsForCall := fake.noticefArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Logger) Panic(arg1 ...interface{}) {
	fake.panicMutex.Lock()
	fake.panicArgsForCall = append(fake.panicArgsForCall, struct {
		arg1 []interface{}
	}{arg1})
	fake.recordInvocation("Panic", []interface{}{arg1})
	fake.panicMutex.Unlock()
	if fake.PanicStub != nil {
		fake.PanicStub(arg1...)
	}
}

func (fake *Logger) PanicCallCount() int {
	fake.panicMutex.RLock()
	defer fake.panicMutex.RUnlock()
	return len(fake.panicArgsForCall)
}

func (fake *Logger) PanicCalls(stub func(...interface{})) {
	fake.panicMutex.Lock()
	defer fake.panicMutex.Unlock()
	fake.PanicStub = stub
}

func (fake *Logger) PanicArgsForCall(i int) []interface{} {
	fake.panicMutex.RLock()
	defer fake.panicMutex.RUnlock()
	argsForCall := fake.panicArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Logger) Panicf(arg1 string, arg2 ...interface{}) {
	fake.panicfMutex.Lock()
	fake.panicfArgsForCall = append(fake.panicfArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	fake.recordInvocation("Panicf", []interface{}{arg1, arg2})
	fake.panicfMutex.Unlock()
	if fake.PanicfStub != nil {
		fake.PanicfStub(arg1, arg2...)
	}
}

func (fake *Logger) PanicfCallCount() int {
	fake.panicfMutex.RLock()
	defer fake.panicfMutex.RUnlock()
	return len(fake.panicfArgsForCall)
}

func (fake *Logger) PanicfCalls(stub func(string, ...interface{})) {
	fake.panicfMutex.Lock()
	defer fake.panicfMutex.Unlock()
	fake.PanicfStub = stub
}

func (fake *Logger) PanicfArgsForCall(i int) (string, []interface{}) {
	fake.panicfMutex.RLock()
	defer fake.panicfMutex.RUnlock()
	argsForCall := fake.panicfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Logger) Warn(arg1 ...interface{}) {
	fake.warnMutex.Lock()
	fake.warnArgsForCall = append(fake.warnArgsForCall, struct {
		arg1 []interface{}
	}{arg1})
	fake.recordInvocation("Warn", []interface{}{arg1})
	fake.warnMutex.Unlock()
	if fake.WarnStub != nil {
		fake.WarnStub(arg1...)
	}
}

func (fake *Logger) WarnCallCount() int {
	fake.warnMutex.RLock()
	defer fake.warnMutex.RUnlock()
	return len(fake.warnArgsForCall)
}

func (fake *Logger) WarnCalls(stub func(...interface{})) {
	fake.warnMutex.Lock()
	defer fake.warnMutex.Unlock()
	fake.WarnStub = stub
}

func (fake *Logger) WarnArgsForCall(i int) []interface{} {
	fake.warnMutex.RLock()
	defer fake.warnMutex.RUnlock()
	argsForCall := fake.warnArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Logger) Warnf(arg1 string, arg2 ...interface{}) {
	fake.warnfMutex.Lock()
	fake.warnfArgsForCall = append(fake.warnfArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	fake.recordInvocation("Warnf", []interface{}{arg1, arg2})
	fake.warnfMutex.Unlock()
	if fake.WarnfStub != nil {
		fake.WarnfStub(arg1, arg2...)
	}
}

func (fake *Logger) WarnfCallCount() int {
	fake.warnfMutex.RLock()
	defer fake.warnfMutex.RUnlock()
	return len(fake.warnfArgsForCall)
}

func (fake *Logger) WarnfCalls(stub func(string, ...interface{})) {
	fake.warnfMutex.Lock()
	defer fake.warnfMutex.Unlock()
	fake.WarnfStub = stub
}

func (fake *Logger) WarnfArgsForCall(i int) (string, []interface{}) {
	fake.warnfMutex.RLock()
	defer fake.warnfMutex.RUnlock()
	argsForCall := fake.warnfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Logger) WithError(arg1 error) log.Logger {
	fake.withErrorMutex.Lock()
	ret, specificReturn := fake.withErrorReturnsOnCall[len(fake.withErrorArgsForCall)]
	fake.withErrorArgsForCall = append(fake.withErrorArgsForCall, struct {
		arg1 error
	}{arg1})
	fake.recordInvocation("WithError", []interface{}{arg1})
	fake.withErrorMutex.Unlock()
	if fake.WithErrorStub != nil {
		return fake.WithErrorStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.withErrorReturns
	return fakeReturns.result1
}

func (fake *Logger) WithErrorCallCount() int {
	fake.withErrorMutex.RLock()
	defer fake.withErrorMutex.RUnlock()
	return len(fake.withErrorArgsForCall)
}

func (fake *Logger) WithErrorCalls(stub func(error) log.Logger) {
	fake.withErrorMutex.Lock()
	defer fake.withErrorMutex.Unlock()
	fake.WithErrorStub = stub
}

func (fake *Logger) WithErrorArgsForCall(i int) error {
	fake.withErrorMutex.RLock()
	defer fake.withErrorMutex.RUnlock()
	argsForCall := fake.withErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Logger) WithErrorReturns(result1 log.Logger) {
	fake.withErrorMutex.Lock()
	defer fake.withErrorMutex.Unlock()
	fake.WithErrorStub = nil
	fake.withErrorReturns = struct {
		result1 log.Logger
	}{result1}
}

func (fake *Logger) WithErrorReturnsOnCall(i int, result1 log.Logger) {
	fake.withErrorMutex.Lock()
	defer fake.withErrorMutex.Unlock()
	fake.WithErrorStub = nil
	if fake.withErrorReturnsOnCall == nil {
		fake.withErrorReturnsOnCall = make(map[int]struct {
			result1 log.Logger
		})
	}
	fake.withErrorReturnsOnCall[i] = struct {
		result1 log.Logger
	}{result1}
}

func (fake *Logger) WithField(arg1 string, arg2 interface{}) log.Logger {
	fake.withFieldMutex.Lock()
	ret, specificReturn := fake.withFieldReturnsOnCall[len(fake.withFieldArgsForCall)]
	fake.withFieldArgsForCall = append(fake.withFieldArgsForCall, struct {
		arg1 string
		arg2 interface{}
	}{arg1, arg2})
	fake.recordInvocation("WithField", []interface{}{arg1, arg2})
	fake.withFieldMutex.Unlock()
	if fake.WithFieldStub != nil {
		return fake.WithFieldStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.withFieldReturns
	return fakeReturns.result1
}

func (fake *Logger) WithFieldCallCount() int {
	fake.withFieldMutex.RLock()
	defer fake.withFieldMutex.RUnlock()
	return len(fake.withFieldArgsForCall)
}

func (fake *Logger) WithFieldCalls(stub func(string, interface{}) log.Logger) {
	fake.withFieldMutex.Lock()
	defer fake.withFieldMutex.Unlock()
	fake.WithFieldStub = stub
}

func (fake *Logger) WithFieldArgsForCall(i int) (string, interface{}) {
	fake.withFieldMutex.RLock()
	defer fake.withFieldMutex.RUnlock()
	argsForCall := fake.withFieldArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Logger) WithFieldReturns(result1 log.Logger) {
	fake.withFieldMutex.Lock()
	defer fake.withFieldMutex.Unlock()
	fake.WithFieldStub = nil
	fake.withFieldReturns = struct {
		result1 log.Logger
	}{result1}
}

func (fake *Logger) WithFieldReturnsOnCall(i int, result1 log.Logger) {
	fake.withFieldMutex.Lock()
	defer fake.withFieldMutex.Unlock()
	fake.WithFieldStub = nil
	if fake.withFieldReturnsOnCall == nil {
		fake.withFieldReturnsOnCall = make(map[int]struct {
			result1 log.Logger
		})
	}
	fake.withFieldReturnsOnCall[i] = struct {
		result1 log.Logger
	}{result1}
}

func (fake *Logger) WithFields(arg1 log.Map) log.Logger {
	fake.withFieldsMutex.Lock()
	ret, specificReturn := fake.withFieldsReturnsOnCall[len(fake.withFieldsArgsForCall)]
	fake.withFieldsArgsForCall = append(fake.withFieldsArgsForCall, struct {
		arg1 log.Map
	}{arg1})
	fake.recordInvocation("WithFields", []interface{}{arg1})
	fake.withFieldsMutex.Unlock()
	if fake.WithFieldsStub != nil {
		return fake.WithFieldsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.withFieldsReturns
	return fakeReturns.result1
}

func (fake *Logger) WithFieldsCallCount() int {
	fake.withFieldsMutex.RLock()
	defer fake.withFieldsMutex.RUnlock()
	return len(fake.withFieldsArgsForCall)
}

func (fake *Logger) WithFieldsCalls(stub func(log.Map) log.Logger) {
	fake.withFieldsMutex.Lock()
	defer fake.withFieldsMutex.Unlock()
	fake.WithFieldsStub = stub
}

func (fake *Logger) WithFieldsArgsForCall(i int) log.Map {
	fake.withFieldsMutex.RLock()
	defer fake.withFieldsMutex.RUnlock()
	argsForCall := fake.withFieldsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Logger) WithFieldsReturns(result1 log.Logger) {
	fake.withFieldsMutex.Lock()
	defer fake.withFieldsMutex.Unlock()
	fake.WithFieldsStub = nil
	fake.withFieldsReturns = struct {
		result1 log.Logger
	}{result1}
}

func (fake *Logger) WithFieldsReturnsOnCall(i int, result1 log.Logger) {
	fake.withFieldsMutex.Lock()
	defer fake.withFieldsMutex.Unlock()
	fake.WithFieldsStub = nil
	if fake.withFieldsReturnsOnCall == nil {
		fake.withFieldsReturnsOnCall = make(map[int]struct {
			result1 log.Logger
		})
	}
	fake.withFieldsReturnsOnCall[i] = struct {
		result1 log.Logger
	}{result1}
}

func (fake *Logger) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.alertMutex.RLock()
	defer fake.alertMutex.RUnlock()
	fake.alertfMutex.RLock()
	defer fake.alertfMutex.RUnlock()
	fake.debugMutex.RLock()
	defer fake.debugMutex.RUnlock()
	fake.debugfMutex.RLock()
	defer fake.debugfMutex.RUnlock()
	fake.errorMutex.RLock()
	defer fake.errorMutex.RUnlock()
	fake.errorfMutex.RLock()
	defer fake.errorfMutex.RUnlock()
	fake.fatalMutex.RLock()
	defer fake.fatalMutex.RUnlock()
	fake.fatalfMutex.RLock()
	defer fake.fatalfMutex.RUnlock()
	fake.fieldsMutex.RLock()
	defer fake.fieldsMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.infofMutex.RLock()
	defer fake.infofMutex.RUnlock()
	fake.noticeMutex.RLock()
	defer fake.noticeMutex.RUnlock()
	fake.noticefMutex.RLock()
	defer fake.noticefMutex.RUnlock()
	fake.panicMutex.RLock()
	defer fake.panicMutex.RUnlock()
	fake.panicfMutex.RLock()
	defer fake.panicfMutex.RUnlock()
	fake.warnMutex.RLock()
	defer fake.warnMutex.RUnlock()
	fake.warnfMutex.RLock()
	defer fake.warnfMutex.RUnlock()
	fake.withErrorMutex.RLock()
	defer fake.withErrorMutex.RUnlock()
	fake.withFieldMutex.RLock()
	defer fake.withFieldMutex.RUnlock()
	fake.withFieldsMutex.RLock()
	defer fake.withFieldsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Logger) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ prana.Logger = new(Logger)
